#define SPECIAL_REG_INPUT_BIT_WIDTH 0
#define SPECIAL_REG_OUTPUT_BIT_WIDTH 1
#define SPECIAL_REG_WEIGHT_BIT_WIDTH 2
#define SPECIAL_REG_GROUP_SIZE 3
#define SPECIAL_REG_ACTIVATION_GROUP_NUM 4
#define SPECIAL_REG_ACTIVATION_ELEMENT_COL_NUM 5
#define SPECIAL_REG_GROUP_INPUT_STEP 6
#define SPECIAL_REG_GROUP_INPUT_OFFSET_ADDR 6
#define SPECIAL_REG_VALUE_SPARSE_MASK_ADDR 7
#define SPECIAL_REG_BIT_SPARSE_META_ADDR 8

#define SPECIAL_REG_SIMD_INPUT_1_BIT_WIDTH 16
#define SPECIAL_REG_SIMD_INPUT_2_BIT_WIDTH 17
#define SPECIAL_REG_SIMD_INPUT_3_BIT_WIDTH 18
#define SPECIAL_REG_SIMD_INPUT_4_BIT_WIDTH 19
#define SPECIAL_REG_SIMD_OUTPUT_BIT_WIDTH 20

// TODO: replace these macro accroding to operator config

// weight
#define WEIGHT_OUT_CHANNEL {{ OUTPUT_CHANNEL }}

// input
#define INPUT_ROW {{ INPUT_ROW }}
#define INPUT_COL {{ INPUT_COL }}
#define INPUT_CHANNEL {{ INPUT_CHANNEL }}

#define OUTPUT_ROW {{ OUTPUT_ROW }}
#define OUTPUT_COL {{ OUTPUT_COL }}
#define OUTPUT_CHANNEL {{ OUTPUT_CHANNEL }}

#define KERNEL_SIZE {{ KERNEL_SIZE }}
#define PADDING {{ PADDING }}
#define STRIDE {{ STRIDE }}

#define N_MACRO_PER_GROUP {{ N_MACRO_PER_GROUP }}
#define N_MACRO_REDUCE {{ N_MACRO_REDUCE }} // N_ROW * N_COMP = 64 * 16 = 1024;
#define N_MACRO {{ N_MACRO }}
#define N_VCOL {{ N_VCOL }}
#define N_GROUP_VCOL {{ N_GROUP_VCOL }}
#define N_GROUP {{ N_GROUP }}
#define N_ROW {{ N_ROW }}
#define N_COMP {{ N_COMP }}


#define INPUT_BUFFER_SIZE_PER_GROUP {{ INPUT_BUFFER_SIZE_PER_GROUP }}
#define N_FROM {{ N_FROM }}
#define N_TO {{ N_TO }}

#define TIME {{ TIME }} // this value is filled by jinja.

#define VALUE_SPARSE_MASK_BASE_ADDR {{ VALUE_SPARSE_MASK_BASE_ADDR }}

#define MAPPING_REDUCE_TO_MACRO_LENGTH {{ MAPPING_REDUCE_TO_MACRO_LENGTH }}
#define MAPPING_MACRO_TO_FROM_LENGTH {{ MAPPING_MACRO_TO_FROM_LENGTH }}
#define MAPPING_MACRO_TO_ROW_LENGTH {{ MAPPING_MACRO_TO_ROW_LENGTH }}
#define MAPPING_FROM_TO_ROW_LENGTH {{ MAPPING_FROM_TO_ROW_LENGTH }}

def copy_input_to_input_buffer_icgt128( // input channel greater than 128
                        null<int8>,
                        local_input< <INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __INPUT_MEMORY__>, 
                        group_use_input_buffer< <1, 1, INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__>,
                        oh<index>,
                        ow<index>,
                        i<index> 
){
    
    // copy one pixel one time
    //num_pixel_per_buffer = INPUT_BUFFER_SIZE_PER_GROUP / INPUT_CHANNEL;
    //num_pixel_per_window = KERNEL_SIZE * KERNEL_SIZE;

    ker_pixel_id = i / INPUT_CHANNEL;
    ker_row_id = ker_pixel_id / KERNEL_SIZE;
    ker_col_id = ker_pixel_id % KERNEL_SIZE;
    row_id = oh + ker_row_id;
    col_id = ow + ker_col_id;
    channel_id = i % INPUT_CHANNEL;
    use_local_input = Slice(local_input,
        [row_id, col_id, channel_id],
        [1, 1, INPUT_BUFFER_SIZE_PER_GROUP],
        [1, 1, 1]
    );
    Trans(use_local_input, group_use_input_buffer);
}

def copy_input_to_input_buffer_iclt128( // input channel less than 128
                        null<int8>,
                        local_input< <INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __INPUT_MEMORY__>, 
                        group_use_input_buffer< <1, 1, INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__>,
                        oh<index>,
                        ow<index>,
                        i<index> 
){
    use_local_input = Slice(local_input,
           [0, 0, 0],
           [1, 1, INPUT_CHANNEL],
           [1, 1, 1]
    );
    
    // copy one pixel one time
    num_pixel_per_buffer = INPUT_BUFFER_SIZE_PER_GROUP / INPUT_CHANNEL;
    num_pixel_per_window = KERNEL_SIZE * KERNEL_SIZE;

    ker_pixel_begin = i / INPUT_CHANNEL;
    ker_pixel_end = Min(ker_pixel_begin + num_pixel_per_buffer, num_pixel_per_window);

    // TODO: unroll this loop
    for ker_pixel_id in range(ker_pixel_begin, ker_pixel_end) carry(null){
        pixel_delta = ker_pixel_id - ker_pixel_begin;

        ker_row_id = ker_pixel_id / KERNEL_SIZE;
        ker_col_id = ker_pixel_id % KERNEL_SIZE;
        row_id = oh + ker_row_id;
        col_id = ow + ker_col_id;
        use_local_input = Slice(local_input,
            [row_id, col_id, 0],
            [1, 1, INPUT_CHANNEL],
            [1, 1, 1]
        );

        input_buffer_addr_begin = pixel_delta * INPUT_CHANNEL;
        use_input_buffer = Slice(group_use_input_buffer,
            [0,0,input_buffer_addr_begin],
            [1,1,INPUT_CHANNEL],
            [1,1,1]
        );
        Trans(use_local_input, use_input_buffer);
        
    };
}

def copy_input_to_input_buffer(
    null<int8>,
    local_input< <INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __INPUT_MEMORY__>, 
    group_use_input_buffer< <1, 1, INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__>,
    oh<index>,
    ow<index>,
    i<index> 
){
    {% if INPUT_BUFFER_SIZE_PER_GROUP % INPUT_CHANNEL == 0 %}
        copy_input_to_input_buffer_iclt128(null, local_input, group_use_input_buffer, oh, ow, i);
    {% elif INPUT_CHANNEL % INPUT_BUFFER_SIZE_PER_GROUP == 0 %}
        copy_input_to_input_buffer_icgt128(null, local_input, group_use_input_buffer, oh, ow, i);
    {% else %}
        Exit(null);
    {% endif %}
}

def copy_input_to_input_buffer_for_all_group(
                        null<int8>,
                        local_input< <INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __INPUT_MEMORY__>, 
                        use_input_buffer< <1, N_GROUP, INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__>,
                        oh<index>,
                        ow<index>,
                        i<index> 
){
        // TODO: unroll this loop
    for g in range(N_GROUP) carry(null){
        group_use_input_buffer = Slice(use_input_buffer,
            [0, g, 0],
            [1, 1, INPUT_BUFFER_SIZE_PER_GROUP],
            [1, 1, 1]
        );
        delta_h = g / 2;
        delta_w = g % 2;
        copy_input_to_input_buffer(null,
            local_input, 
            group_use_input_buffer,
            oh + delta_h,
            ow + delta_w,
            i
        );
    };
}

def main(null<int8>){
    // input, weight, mask and index will be prepared in memory image
    global_input = Buffer(<INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __GLOBAL__);
    global_weight = Buffer(<TIME, N_TO, N_GROUP, N_MACRO_PER_GROUP, N_VCOL>, int8, __GLOBAL__);
    global_mask = Buffer(<TIME, N_FROM, N_MACRO_PER_GROUP>, int1, __GLOBAL__);

    mapping_reduce_to_macro = Buffer(<MAPPING_REDUCE_TO_MACRO_LENGTH>, index, __GLOBAL__);
    mapping_macro_to_from = Buffer(<MAPPING_MACRO_TO_FROM_LENGTH>, index, __GLOBAL__);
    mapping_macro_to_row = Buffer(<MAPPING_MACRO_TO_ROW_LENGTH>, index, __GLOBAL__);
    mapping_from_to_row = Buffer(<MAPPING_FROM_TO_ROW_LENGTH>, index, __GLOBAL__);


    global_output = Buffer(<OUTPUT_ROW, OUTPUT_COL, OUTPUT_CHANNEL>, int32, __GLOBAL__);
    
    // Copy input and index into local memory
    local_input = Buffer(<INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __INPUT_MEMORY__);
    Trans(global_input, local_input);


    // Prepare memory's that will be used
    
    // Create a buffer to store output
    local_output = Buffer(<OUTPUT_ROW, OUTPUT_COL, OUTPUT_CHANNEL>, int32, __OUTPUT_MEMORY__);
    local_output_for_temp_sum = Buffer(<N_GROUP_VCOL>, int32, __OUTPUT_MEMORY__);

    // PIM input reg buffer, it is a double-buffer. Each group use 128 byte, total 4 groups.
    pim_input_reg_buffer = Buffer(<2,N_GROUP,INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__);

    // PIM output reg buffer, it's capacity is 4096 bytes, but we use it to store int32 data, so the buffer's shape is 1024
    pim_output_reg_buffer = Buffer(<1024>, int32, __PIM_OUTPUT_REG_BUFFER__);
    
    // Macros
    macros = Buffer(<N_ROW, N_COMP, N_GROUP, N_GROUP_VCOL>, int8, __MACRO__);

    // Mask Buffer
    buffer_mask = Buffer(<N_MACRO_REDUCE, N_FROM, N_MACRO_PER_GROUP>, int1, __PIM_MASK_DATA_REG_BUFFER__);

    // Spill
    local_spill = Buffer(<4>, index, __INPUT_MEMORY__);

    // TODO: Add 'SPECIAL_REG_' prefix for these macro.
    SpecialRegSet(SPECIAL_REG_INPUT_BIT_WIDTH, 8);
    SpecialRegSet(SPECIAL_REG_WEIGHT_BIT_WIDTH, 8);
    SpecialRegSet(SPECIAL_REG_OUTPUT_BIT_WIDTH, 32);
    SpecialRegSet(SPECIAL_REG_GROUP_SIZE, N_MACRO_PER_GROUP);
    SpecialRegSet(SPECIAL_REG_ACTIVATION_GROUP_NUM, N_GROUP);
    SpecialRegSet(SPECIAL_REG_ACTIVATION_ELEMENT_COL_NUM, N_GROUP_VCOL);
    SpecialRegSet(SPECIAL_REG_GROUP_INPUT_STEP, N_FROM);

    SpecialRegSet(SPECIAL_REG_SIMD_INPUT_1_BIT_WIDTH, 32);
    SpecialRegSet(SPECIAL_REG_SIMD_INPUT_2_BIT_WIDTH, 32);
    SpecialRegSet(SPECIAL_REG_SIMD_OUTPUT_BIT_WIDTH, 32);

    macro_to_from_begin = 0;
    row_abs_begin = 0;
    from_to_row_begin = 0;
    for i_reduce_to_macro in range(0, MAPPING_REDUCE_TO_MACRO_LENGTH) 
        carry (macro_to_from_begin, from_to_row_begin, row_abs_begin){
        // for out_channel_begin in range(0, WEIGHT_OUT_CHANNEL, N_GROUP_VCOL) 
        // carry (macro_to_from_begin, from_to_row_begin) 

        out_channel_begin = i_reduce_to_macro * N_GROUP_VCOL;
        out_channel_end = Min(WEIGHT_OUT_CHANNEL, out_channel_begin + N_GROUP_VCOL);
        use_vcol = out_channel_end - out_channel_begin;

        macro_to_from_size = Load(mapping_reduce_to_macro, [i_reduce_to_macro]);
        macro_to_from_end = macro_to_from_begin + macro_to_from_size;
        begin_tile_in_window = 0;
        for i_macro_to_from in range(macro_to_from_begin, macro_to_from_end) 
            carry (begin_tile_in_window, from_to_row_begin, row_abs_begin){
            
            row_size = Load(mapping_macro_to_row, [i_macro_to_from]); // how many 16 in a macro(i.e. how many row to use)
            from_to_row_size = Load(mapping_macro_to_from, [i_macro_to_from]); // how many 128 in a macro

            // Step 1: Prepare weight
            // notice that weight.shape = <TIME, N_TO, N_GROUP, N_MACRO_PER_GROUP, N_VCOL>
            use_weight = Slice(global_weight, 
                        [row_abs_begin, 0, 0, 0, 0],                                // offsets
                        [row_size, N_TO, N_GROUP, N_MACRO_PER_GROUP, N_VCOL],   // sizes
                        [1,1,1,1,1]                                                     // strides
                        );
            use_macros = Slice(macros,
                [0, 0, 0, 0],
                [row_size, N_COMP, N_GROUP, N_GROUP_VCOL],
                [1,1,1,1]
            );
            Trans(use_weight, use_macros);

            // Step 2: Prepare mask
            // global_mask.shape = <TIME, N_FROM, N_MACRO_PER_GROUP>
            use_global_mask = Slice(global_mask, 
                [row_abs_begin, 0, 0],
                [row_size, N_FROM, N_MACRO_PER_GROUP],
                [1, 1, 1]
            );
            // buffer_mask.shape = <FROM_OVER_TO, N_FROM, N_MACRO_PER_GROUP>
            // TODO: It will be error when weight_time_size > FROM_OVER_TO. Check this later.
            use_buffer_mask = Slice(buffer_mask,
                [0, 0, 0],
                [row_size, N_FROM, N_MACRO_PER_GROUP],
                [1, 1, 1]
            );
            Trans(use_global_mask, use_buffer_mask);


            // begin_tile_in_window
            t_ = KERNEL_SIZE * KERNEL_SIZE;
            sliding_window_size = t_ * INPUT_CHANNEL;
            tile_size_in_window = from_to_row_size * N_FROM;
            end_tile_in_window = Min(sliding_window_size, begin_tile_in_window + tile_size_in_window);

            // Iter over output's height and width
            // Notice that we have 4 group, so each time we deal with 4 pixel in a square.
            // So, the 'step' of oh and ow is 2.
            double_buffer_id = 1;
            // Save(local_spill,[1],double_buffer_id);
            for oh in range(0,OUTPUT_ROW,2) carry(double_buffer_id) {
                for ow in range(0,OUTPUT_COL,2) carry(double_buffer_id) {
                    // Double buffer index
                    // double_buffer_id = Load(local_spill,[1]);
                    double_buffer_id = 1 - double_buffer_id;
                    // Save(local_spill,[1],double_buffer_id);

                    // Step 3: Prepare input
                    use_input_buffer = Slice(pim_input_reg_buffer, 
                        [double_buffer_id, 0, 0], 
                        [1, N_GROUP, INPUT_BUFFER_SIZE_PER_GROUP], 
                        [1,1,1]
                    );
                    
                    // iter over a sliding window : KERNEL_SIZE * KERNEL_SIZE * INPUT_CHANNEL
                    
                    row_to_activate = 0;
                    sparse_mask_addr = VALUE_SPARSE_MASK_BASE_ADDR;
                    // Save(local_spill, [2], sparse_mask_addr);
                    // Save(local_spill, [3], row_to_activate);

                    from_to_row_end = from_to_row_begin + from_to_row_size;
                    for i_from_to_row in range(from_to_row_begin, from_to_row_end) carry (row_to_activate, sparse_mask_addr){
                        i_rel_from_to_row = i_from_to_row - from_to_row_begin;
                        tt_ = i_rel_from_to_row * N_FROM;
                        i_tile_in_window = begin_tile_in_window + tt_;
                        copy_input_to_input_buffer_for_all_group(null,
                            local_input, 
                            use_input_buffer,
                            oh,
                            ow,
                            i_tile_in_window
                        );
                        // all 4 * 128 inputs are now in input_reg_buf.

                        // Step 4: do multiple 128 to 16 compute
                        sparse_mask_step_element = N_FROM * N_MACRO_PER_GROUP;
                        sparse_mask_step = sparse_mask_step_element / 8; // mask is stored by 1bit
                        compute_time = Load(mapping_from_to_row, [i_from_to_row]);
                        // sparse_mask_addr = Load(local_spill, [2]);
                        // row_to_activate = Load(local_spill, [3]);
                        for i_compute in range(compute_time) carry (row_to_activate, sparse_mask_addr){
                            // give mask addr to special register
                            SpecialRegSet(SPECIAL_REG_VALUE_SPARSE_MASK_ADDR, sparse_mask_addr);
                            // activate macro
                            activate_macro = Slice(use_macros,
                                [row_to_activate, 0, 0, 0],
                                [1,  N_COMP, N_GROUP, N_GROUP_VCOL],
                                [1,1,1,1]
                            );
                            //Print(sparse_mask_addr);
                            //Debug();
                            CIMComputeValueSparse(use_input_buffer, activate_macro, pim_output_reg_buffer);
                            
                            row_to_activate = row_to_activate + 1;
                            sparse_mask_addr = sparse_mask_addr + sparse_mask_step;
                        };
                        // Save(local_spill, [2], sparse_mask_addr);
                        // Save(local_spill, [3], row_to_activate);
                        
                    };
                    // check output of first 4 output pixels.
                    
                    CIMOutput(pim_output_reg_buffer);

                    // TODO: unroll this loop
                    for group_i in range(4) carry (null){
                        output_buffer_group_i = Slice(pim_output_reg_buffer, [group_i * N_GROUP_VCOL], [use_vcol], [1]);
                        delta_h = group_i / 2;
                        delta_w = group_i % 2;
                        Trans(output_buffer_group_i, local_output_for_temp_sum);

                        local_output_group_i = Slice(local_output, [oh+delta_h, ow+delta_w, out_channel_begin], [1, 1, use_vcol], [1,1,1]);
                        VVAdd(local_output_for_temp_sum, local_output_group_i, local_output_group_i);
                    };
                };
            };

            begin_tile_in_window = end_tile_in_window;
            row_abs_begin = row_abs_begin + row_size;
            from_to_row_begin = from_to_row_begin + from_to_row_size;

        }; // end of out_reduce_i
        macro_to_from_begin = macro_to_from_end;
        
    }; // end of out_channel_begin
    Trans(local_output, global_output);
    //Debug(null);
    Trans(global_input,global_input);
    Trans(global_weight,global_weight);
    Trans(global_mask,global_mask);
    Trans(mapping_reduce_to_macro);
    Trans(mapping_macro_to_from);
    Trans(mapping_macro_to_row);
    Trans(mapping_from_to_row);
    // Trans(global_index,global_index);
    // Trans(global_out_spatial_tile_size_list,global_out_spatial_tile_size_list);
}