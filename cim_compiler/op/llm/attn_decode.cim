{% include 'op/common/def_special_regs.cim' %}
{% include 'op/common/simd.cim' %}

{# Add parameter validation #}
{% if head_hidden % N_COMP != 0 %}
    {% set error_msg = "head_hidden must be divisible by N_COMP" %}
    {{ raise(error_msg) }}
{% endif %}
{% if seqlen % N_GROUP_VCOL != 0 %}
    {% set error_msg = "seqlen must be divisible by N_GROUP_VCOL" %}
    {{ raise(error_msg) }}
{% endif %}
{% if transpose_col != head_hidden %}
    {% set error_msg = "transpose_col must equals head_hidden" %}
    {{ raise(error_msg) }}
{% endif %}
{% if not (seqlen >= transpose_row and seqlen % transpose_row == 0) %}
    {% set error_msg = "seqlen must be greater than transpose_row" %}
    {{ raise(error_msg) }}
{% endif %}

def load_into_macro(src< <-1, -1>, fp16, __GLOBAL__>, 
                    macro< <-1,  {{N_COMP}}, 1, {{N_GROUP_VCOL}}>, fp16, __MACRO__>
                    ){
    src_row = Shape(src, 0);
    src_col = Shape(src, 1);

    out_row_size = src_row / {{N_COMP}};
    out_col_size = src_col / {{N_GROUP_VCOL}};

    // TODO: optimize when src_col == N_GROUP_VCOL

    macro_row = Shape(macro, 0);
    for r_out in range(0, out_row_size) carry () {
        for c_out in range(0, out_col_size) carry () {
            for r_in in range(0, {{N_COMP}}) carry () {
                sub_src = src[
                    r_out * {{N_COMP}} + r_in, 
                    c_out * {{N_GROUP_VCOL}} : (c_out + 1) * {{N_GROUP_VCOL}}
                ];
                
                sub_macro = macro[c_out * out_row_size + r_out, r_in, :, : ];

                Trans(sub_src, sub_macro);
            };
        };
    };
}

def load_single_transpose_into_macro(
        transpose_unit< <1, -1>, fp16, __TRANSPOSE_MEMORY__>,
        macro< <-1,  {{N_COMP}}, 1, {{N_GROUP_VCOL}}>, fp16, __MACRO__>,
        row_outer_src<index>
    ){
    transpose_row = {{transpose_row}};
    transpose_col = {{transpose_col}};

    for r_transpose_out in range(0, transpose_col) carry () {
        transpose_unit_out_line = transpose_unit[:, r_transpose_out * transpose_row : (r_transpose_out + 1) * transpose_row];
        
        
        // A little complicated here.
        col_outer_macro = row_outer_src % ({{N_GROUP_VCOL}} / transpose_row);
        row_outer_macro = row_outer_src / ({{N_GROUP_VCOL}} / transpose_row);

        col_macro_begin = col_outer_macro * transpose_row;
        col_macro_end = (col_outer_macro + 1) * transpose_row;
        
        abs_row_macro = row_outer_macro * transpose_col + r_transpose_out;
        row_macro = abs_row_macro / {{N_COMP}};
        comp_macro = abs_row_macro % {{N_COMP}};

        macro_line = macro[row_macro, comp_macro, 0, col_macro_begin:col_macro_end];

        Trans(transpose_unit_out_line, macro_line);
    };
}

def load_transpose_into_macro(src< <-1, -1>, fp16, __GLOBAL__>, 
                    macro< <-1,  {{N_COMP}}, 1, {{N_GROUP_VCOL}}>, fp16, __MACRO__>,
                    transpose_unit< <2, -1>, fp16, __TRANSPOSE_MEMORY__>
                    ){
    transpose_row = {{transpose_row}};
    transpose_col = {{transpose_col}};

    src_row = Shape(src, 0);
    src_col = Shape(src, 1);

    out_row_size = src_row / transpose_row;
    out_col_size = src_col / transpose_col;

    // double buffer transpose

    // write 0
    Trans(src[:transpose_row, :], transpose_unit[0,:]);

    for row_outer_src in range(1, out_row_size) carry () {

        // write row_outer_src % 2
        Trans(
            src[row_outer_src * transpose_row: (row_outer_src + 1) * transpose_row, :], 
            transpose_unit[row_outer_src % 2,:]
        );

        // read from (row_outer_src % 2) + 1
        load_single_transpose_into_macro(
            transpose_unit[(row_outer_src - 1) % 2, :],
            macro,
            row_outer_src - 1
        );
    };

    // read from (out_row_size - 1) % 2
    load_single_transpose_into_macro(
        transpose_unit[(out_row_size - 1) % 2, :],
        macro,
        out_row_size - 1
    );
}

def gemv(src< <-1>, fp16, __OUTPUT_MEMORY__>, 
         macro< <-1, {{N_COMP}}, 1, {{N_GROUP_VCOL}}>, fp16, __MACRO__>,
         dst< <-1>, fp16, __OUTPUT_MEMORY__>,
         n_reduce_row<index>,
         pim_input_reg_buffer< <-1>, fp16, __PIM_INPUT_REG_BUFFER__>,
         pim_output_reg_buffer< <-1>, fp16, __PIM_OUTPUT_REG_BUFFER__>
){
    src_row = Shape(src, 0);

    n_macro_row = Shape(macro, 0);
    // Print(n_macro_row);
    n_spatial_row = n_macro_row / n_reduce_row;

    use_input_reg_buffer = pim_input_reg_buffer[0:{{N_COMP}}];
    use_output_reg_buffer = pim_output_reg_buffer[0:{{N_GROUP_VCOL}}];
    
    for i_spatial_row in range(0, n_spatial_row) carry () {
        for i_reduce_row in range(0, n_reduce_row) carry () {
            macro_for_compute = macro[i_spatial_row * n_reduce_row + i_reduce_row, :, :, :];

            input_for_compute = src[
                i_reduce_row * {{N_COMP}} : (i_reduce_row + 1) * {{N_COMP}}
            ];
            
            Trans(input_for_compute, use_input_reg_buffer);
            CIMComputeDense(use_input_reg_buffer, macro_for_compute);
        };
        CIMOutput({{N_GROUP_VCOL}}, 0, use_output_reg_buffer);

        output = dst[i_spatial_row * {{N_GROUP_VCOL}} : (i_spatial_row + 1) * {{N_GROUP_VCOL}}];
        Trans(use_output_reg_buffer, output);
    };
}

def set_special_regs(){
    SpecialRegSet(SPECIAL_REG_INPUT_BIT_WIDTH, 16);
    SpecialRegSet(SPECIAL_REG_WEIGHT_BIT_WIDTH, 16);
    SpecialRegSet(SPECIAL_REG_OUTPUT_BIT_WIDTH, 16);
    SpecialRegSet(SPECIAL_REG_GROUP_SIZE, {{N_MACRO_PER_GROUP}});
    SpecialRegSet(SPECIAL_REG_ACTIVATION_GROUP_NUM, {{N_GROUP}});
    SpecialRegSet(SPECIAL_REG_ACTIVATION_ELEMENT_COL_NUM, {{N_GROUP_VCOL}});

    SpecialRegSet(SPECIAL_REG_SIMD_INPUT_1_BIT_WIDTH, 16);
    SpecialRegSet(SPECIAL_REG_SIMD_OUTPUT_BIT_WIDTH, 16);

    SpecialRegSet(SPECIAL_REG_DTYPE_MACRO_IS_FLOAT, 1);
    SpecialRegSet(SPECIAL_REG_DTYPE_SIMD_IS_FLOAT, 1);
}

def main(){
    set_special_regs();

    global_pimset_mask = Buffer(<{{N_GROUP_VCOL}}>, int1, __GLOBAL__);
    local_pimset_mask = Buffer(<{{N_GROUP_VCOL}}>, int1, __INPUT_MEMORY__);
    Trans(global_pimset_mask, local_pimset_mask);
    CIMSet(local_pimset_mask);
    
    q_global = Buffer(<{{head_hidden}}>, fp16, __GLOBAL__);
    k_global = Buffer(<{{seqlen}}, {{head_hidden}}>, fp16, __GLOBAL__);
    v_global = Buffer(<{{seqlen}}, {{head_hidden}}>, fp16, __GLOBAL__);
    output_global = Buffer(<{{head_hidden}}>, fp16, __GLOBAL__);
    
    macros = Buffer(<{{N_ROW}}, {{N_COMP}}, 1, {{N_GROUP_VCOL}}>, fp16, __MACRO__);
    pim_input_reg_buffer = Buffer(<{{N_COMP}}>, fp16, __PIM_INPUT_REG_BUFFER__);
    pim_output_reg_buffer = Buffer(<{{N_GROUP_VCOL}}>, fp16, __PIM_OUTPUT_REG_BUFFER__);

    // step 0: load q into local
    q_local = Buffer(<{{head_hidden}}>, fp16, __OUTPUT_MEMORY__);
    Trans(q_global, q_local);

    // step 1: load all kv caches into macro
    k_row_begin = 0;
    k_row_size = {{ (head_hidden // N_COMP) * (seqlen // N_GROUP_VCOL) }};
    k_row_end = k_row_begin + k_row_size;
    k_macro = macros[k_row_begin:k_row_end, 0:{{N_COMP}}, 0:1, 0:{{N_GROUP_VCOL}}];

    v_row_begin = k_row_end;
    v_row_size = {{ (seqlen // N_COMP) * (head_hidden // N_GROUP_VCOL) }};
    v_row_end = v_row_begin + v_row_size;
    v_macro = macros[v_row_begin:v_row_end, 0:{{N_COMP}}, 0:1, 0:{{N_GROUP_VCOL}}];
    
    transpose_unit = Buffer(<2, {{transpose_row * transpose_col}}>, fp16, __TRANSPOSE_MEMORY__);
    load_transpose_into_macro(k_global, k_macro, transpose_unit);
    load_into_macro(v_global, v_macro);

    // step 2: compute qK^T
    attn_out1 = Buffer(<{{seqlen}}>, fp16, __OUTPUT_MEMORY__);
    gemv(q_local, k_macro, attn_out1, {{ head_hidden // N_COMP }}, pim_input_reg_buffer, pim_output_reg_buffer);

    // step 3: compute softmax(qK^T)
    score = Buffer(<{{seqlen}}>, fp16, __OUTPUT_MEMORY__);
    SIMD(SOFTMAX, attn_out1, score);

    // step 4: compute softmax(qK^T)V
    attn_out2= Buffer(<{{head_hidden}}>, fp16, __OUTPUT_MEMORY__);
    gemv(score, v_macro, attn_out2, {{ seqlen // N_COMP }}, pim_input_reg_buffer, pim_output_reg_buffer);

    // step 5: output
    Trans(attn_out2, output_global);
}