///////////////////////////////////////////////////////////////////////////////
// This kernel run im2col offline, and run a matmul to get the conv2d result.//
///////////////////////////////////////////////////////////////////////////////

#define INPUT_BIT_WIDTH 0
#define OUTPUT_BIT_WIDTH 1
#define WEIGHT_BIT_WIDTH 2
#define GROUP_SIZE 3
#define ACTIVATION_GROUP_NUM 4
#define ACTIVATION_ELEMENT_COL_NUM 5
#define GROUP_INPUT_STEP 6
#define GROUP_INPUT_OFFSET_ADDR 6
#define VALUE_SPARSE_MASK_ADDR 7
#define BIT_SPARSE_META_ADDR 8

#define SIMD_INPUT_1_BIT_WIDTH 16
#define SIMD_INPUT_2_BIT_WIDTH 17
#define SIMD_INPUT_3_BIT_WIDTH 18
#define SIMD_INPUT_4_BIT_WIDTH 19
#define SIMD_OUTPUT_BIT_WIDTH 20

// TODO: replace these macro accroding to operator config
// weight
#define WEIGHT_SPATIAL 128
#define WEIGHT_REDUCE 576 // 128 * 3 * 3
// input
#define INPUT_SPATIAL 256 // 16 * 16
#define INPU_REDUCE 576

#define N_MACRO 4
#define N_VCOL 2
#define N_GROUP_VCOL 8 // 2 * 4
#define N_GROUP 1
#define N_ROW 4
#define N_COMP 4

def main(null<int8>){
    // input and weight will be prepared in memory image
    input = Buffer(<INPUT_SPATIAL, INPU_REDUCE>, int8, global);
    weight = Buffer(<WEIGHT_SPATIAL, WEIGHT_REDUCE>, int8, global);
    output = Buffer(<INPUT_SPATIAL,WEIGHT_SPATIAL>, int32, global);

    in_buffer = Buffer(<4>, int8, input_buffer);
    out_buffer = Buffer(<8,8>, int32, output_buffer);
    macros = Buffer(<N_ROW, N_COMP, 1, N_GROUP_VCOL>, int8, macro);

    macro_use = Slice(macros, [0,0,0,0],[2,4,1,8],[1,1,1,1]);
    Trans(weight, macro_use);

    SpecialRegSet(INPUT_BIT_WIDTH, 8);
    SpecialRegSet(WEIGHT_BIT_WIDTH, 8);
    SpecialRegSet(OUTPUT_BIT_WIDTH, 32);
    SpecialRegSet(GROUP_SIZE, 4);
    SpecialRegSet(ACTIVATION_GROUP_NUM, 1);
    SpecialRegSet(ACTIVATION_ELEMENT_COL_NUM, 8);

    n_macro_reduce = N_ROW * N_COMP;

    for out_j in range(0, WEIGHT_SPATIAL, N_GROUP_VCOL) carry (null) {
        for out_k in range(0, WEIGHT_REDUCE, n_macro_reduce) carry (null) {
            for i in range(0, INPUT_SPATIAL, 1) carry (null) {
            
            
            };
        };
    };

    for i in range(8) carry (null){
        out_buffer_use = Slice(out_buffer, [i,0], [1,8], [1,1]);
        for j in range(0, 2) carry (null){
            input_use = Slice(input, [i, j * 4], [1,4], [1,1]);
            Trans(input_use, in_buffer);
            macro_use = Slice(macros, [j,0,0,0],[1,4,1,8],[1,1,1,1]);
            CIMComputeDense(in_buffer, macro_use, out_buffer_use);
        };
    };

    //write output
    Trans(out_buffer, output);
}