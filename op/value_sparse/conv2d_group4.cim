#define INPUT_BIT_WIDTH 0
#define OUTPUT_BIT_WIDTH 1
#define WEIGHT_BIT_WIDTH 2
#define GROUP_SIZE 3
#define ACTIVATION_GROUP_NUM 4
#define ACTIVATION_ELEMENT_COL_NUM 5
#define GROUP_INPUT_STEP 6
#define GROUP_INPUT_OFFSET_ADDR 6
#define VALUE_SPARSE_MASK_ADDR 7
#define BIT_SPARSE_META_ADDR 8

#define SIMD_INPUT_1_BIT_WIDTH 16
#define SIMD_INPUT_2_BIT_WIDTH 17
#define SIMD_INPUT_3_BIT_WIDTH 18
#define SIMD_INPUT_4_BIT_WIDTH 19
#define SIMD_OUTPUT_BIT_WIDTH 20

// TODO: replace these macro accroding to operator config

// weight
#define WEIGHT_OUT_CHANNEL {{ WEIGHT_OUT_CHANNEL }}

// input
#define INPUT_ROW {{ INPUT_ROW }}
#define INPUT_COL {{ INPUT_COL }}
#define INPUT_CHANNEL {{ INPUT_CHANNEL }}

#define OUTPUT_ROW {{ OUTPUT_ROW }}
#define OUTPUT_COL {{ OUTPUT_COL }}
#define OUTPUT_CHANNEL {{ OUTPUT_CHANNEL }}

#define KERNEL_SIZE {{ KERNEL_SIZE }}
#define PADDING {{ PADDING }}
#define STRIDE {{ STRIDE }}

#define N_MACRO {{ N_MACRO }}
#define N_MACRO_PER_GROUP {{ N_MACRO_PER_GROUP }}
#define N_VCOL {{ N_VCOL }}
#define N_GROUP_VCOL {{ N_GROUP_VCOL }}
#define N_GROUP {{ N_GROUP }}
#define N_ROW {{ N_ROW }}
#define N_COMP {{ N_COMP }}
#define N_MACRO_REDUCE {{ N_MACRO_REDUCE }} // N_ROW * N_COMP = 64 * 16 = 1024;

#define INPUT_BUFFER_SIZE_PER_GROUP {{ INPUT_BUFFER_SIZE_PER_GROUP }}

#define TIME {{ time }} // this value is filled by jinja.

def copy_input_to_input_buffer(
                        null<int8>,
                        local_input< <INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __GLOBAL__>, 
                        group_use_input_buffer< <1, 1, INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__>,
                        oh<index>,
                        ow<index>,
                        i<index> 
){
    {% if INPUT_CHANNEL % input_buffer_size_per_group == 0 %}
        
        num_buffer_per_pixel = INPUT_CHANNEL / INPUT_BUFFER_SIZE_PER_GROUP;
        ker_pixel_id = i / num_buffer_per_pixel;
        buffer_in_pixel = i % num_buffer_per_pixel;
        ker_row_id = ker_pixel_id / KERNEL_SIZE;
        ker_col_id = ker_pixel_id % KERNEL_SIZE;
        row_id = oh + ker_row_id;
        col_id = ow + ker_col_id;
        channel_id = buffer_in_pixel * INPUT_BUFFER_SIZE_PER_GROUP;
        use_local_input = Slice(local_input,
            [row_id, col_id, channel_id],
            [1, 1, INPUT_BUFFER_SIZE_PER_GROUP],
            [1, 1, 1]
        );
        Trans(use_local_input, group_use_input_buffer);

    {% else if INPUT_BUFFER_SIZE_PER_GROUP % INPUT_CHANNEL == 0 %}

        // copy one pixel one time
        num_pixel_per_buffer = INPUT_BUFFER_SIZE_PER_GROUP / INPUT_CHANNEL;
        ker_pixel_begin = i * num_pixel_per_buffer;
        // TODO: unroll this loop
        for pixel_delta in range(num_pixel_per_buffer){
            ker_pixel_id = ker_pixel_begin + pixel_delta;
            ker_row_id = ker_pixel_id / KERNEL_SIZE;
            ker_col_id = ker_pixel_id % KERNEL_SIZE;
            row_id = oh + ker_row_id;
            col_id = ow + ker_col_id;
            use_local_input = Slice(local_input,
                [row_id, col_id, 0],
                [1, 1, INPUT_CHANNEL],
                [1, 1, 1]
            );

            input_buffer_addr_begin = pixel_delta * INPUT_CHANNEL;
            use_input_buffer = Slice(group_use_input_buffer,
                [0,0,input_buffer_addr_begin],
                [1,1,INPUT_CHANNEL],
                [1,1,1]
            );
            Trans(use_local_input, use_input_buffer);

        };

    {% else %}
        not implement this yet !!
    {% endif %}
}

def copy_input_to_input_buffer_for_all_group(
                        null<int8>,
                        local_input< <INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __GLOBAL__>, 
                        use_input_buffer< <1, N_GROUP, INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__>,
                        oh<index>,
                        ow<index>,
                        i<index> 
){
    // TODO: unroll this loop
    for g in range(N_GROUP) carry(null){
        group_use_input_buffer = Slice(use_input_buffer,
            [0, g, 0],
            [1, 1, INPUT_BUFFER_SIZE_PER_GROUP],
            [1, 1, 1]
        );
        delta_h = g / 2;
        delta_w = g % 2;
        copy_input_to_input_buffer(null,
            local_input, 
            group_use_input_buffer,
            oh + delta_h,
            ow + delta_w,
            i
        );
    };
};

def main(null<int8>){
    // input, weight, mask and index will be prepared in memory image
    global_input = Buffer(<INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __GLOBAL__);
    global_weight = Buffer(<TIME, N_TO, N_GROUP, N_MACRO_PER_GROUP, N_VCOL>, int8, __GLOBAL__);
    global_mask = Buffer(<TIME, N_TO, N_MACRO_PER_GROUP>, int1, __GLOBAL__);
    global_index = Buffer(<TIME>, index, __GLOBAL__);
    global_out_spatial_tile_size_list = Buffer(<TIME>, index, __GLOBAL__); //TODO: this is shorter than TIME.

    global_output = Buffer(<OUTPUT_ROW, OUTPUT_COL, OUTPUT_CHANNEL>, int32, __GLOBAL__);
    
    // Copy input and index into local memory
    local_input = Buffer(<INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __GLOBAL__);
    Trans(global_input, local_input);
    local_index = Buffer(<TIME, N_TO, N_MACRO_PER_GROUP>, index, __LOCAL__);
    Trans(global_index, local_index);

    // Prepare memory's that will be used

    // Create a buffer to store output
    local_output = Buffer(<OUTPUT_ROW, OUTPUT_COL, OUTPUT_CHANNEL>, int32, __LOCAL__);

    // PIM input reg buffer, it is a double-buffer. Each group use 128 byte, total 4 groups.
    pim_input_reg_buffer = Buffer(<2,N_GROUP,INPUT_BUFFER_SIZE_PER_GROUP>, int8, __PIM_INPUT_REG_BUFFER__);

    // PIM output reg buffer, it's capacity is 4096 bytes, but we use it to store int32 data, so the buffer's shape is 1024
    pim_output_reg_buffer = Buffer(<1024>, int32, __PIM_OUTPUT_REG_BUFFER__);
    
    // Macros
    macros = Buffer(<N_ROW, N_COMP, N_GROUP, N_GROUP_VCOL>, int8, macro);

    SpecialRegSet(INPUT_BIT_WIDTH, 8);
    SpecialRegSet(WEIGHT_BIT_WIDTH, 8);
    SpecialRegSet(OUTPUT_BIT_WIDTH, 32);
    SpecialRegSet(GROUP_SIZE, N_MACRO_PER_GROUP);
    SpecialRegSet(ACTIVATION_GROUP_NUM, N_GROUP);
    SpecialRegSet(ACTIVATION_ELEMENT_COL_NUM, N_GROUP_VCOL);

    weight_time_begin = 0;
    for out_channel_outer_i in range(0, WEIGHT_OUT_CHANNEL/N_GROUP_VCOL) carry (weight_addr_begin) {
        out_channel_begin = out_channel_outer_i * N_GROUP_VCOL;

        weight_time_size = Load(global_out_spatial_tile_size_list, [out_channel_outer_i]); // how many row this filter use.

        // Step 1: Prepare weight
        // notice that weight.shape = <TIME, N_TO, N_GROUP, N_MACRO_PER_GROUP, N_VCOL>
        use_weight = Slice(weight, 
                    [weight_addr_begin, 0, 0, 0, 0],                                // offsets
                    [weight_time_size, N_TO, N_GROUP, N_MACRO_PER_GROUP, N_VCOL],   // sizes
                    [1,1,1,1,1]                                                    // strides
                    );
        Trans(use_weight, macros); // use_weight can fill macros completely
        weight_time_begin = weight_time_begin + weight_time_size;


        // Iter over output's height and width
        // Notice that we have 4 group, so each time we deal with 4 pixel in a square.
        // So, the 'step' of oh and ow is 2.
        double_buffer_id = 0
        for oh in range(0,OUT_HEIGHT,2) carry(double_buffer_id) {
            for ow in range(0,OUT_WIDTH,2) carry(double_buffer_id) {
                // Prepare to generate one pixel's result (or partial sum)

                // Double buffer index
                double_buffer_id = 1 - double_buffer_id;
                use_input_buffer = Slice(pim_input_reg_buffer, 
                    [double_buffer_id, 0, 0], 
                    [1, N_GROUP, INPUT_BUFFER_SIZE_PER_GROUP], 
                    [1,1,1]
                );

                // Step 2: Prepare input
                // iter over a sliding window : KERNEL_SIZE * KERNEL_SIZE * INPUT_CHANNEL
                sliding_window_size = KERNEL_SIZE * KERNEL_SIZE * INPUT_CHANNEL;
                for i in range(0, sliding_window_size, N_FROM) carry(null){
                    copy_input_to_input_buffer_for_all_group(
                        local_input, 
                        use_input_buffer
                        oh,
                        ow,
                        i
                    );
                    // continue here
                };
            };
        };
    };
}