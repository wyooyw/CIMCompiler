#define INPUT_BIT_WIDTH 0
#define OUTPUT_BIT_WIDTH 1
#define WEIGHT_BIT_WIDTH 2
#define GROUP_SIZE 3
#define ACTIVATION_GROUP_NUM 4
#define ACTIVATION_ELEMENT_COL_NUM 5
#define GROUP_INPUT_STEP 6
#define GROUP_INPUT_OFFSET_ADDR 6
#define VALUE_SPARSE_MASK_ADDR 7
#define BIT_SPARSE_META_ADDR 8

#define SIMD_INPUT_1_BIT_WIDTH 16
#define SIMD_INPUT_2_BIT_WIDTH 17
#define SIMD_INPUT_3_BIT_WIDTH 18
#define SIMD_INPUT_4_BIT_WIDTH 19
#define SIMD_OUTPUT_BIT_WIDTH 20

// TODO: replace these macro accroding to operator config

// weight
#define WEIGHT_OUT_CHANNEL 
#define WEIGHT_REDUCE 576 // 128 * 3 * 3

// input
#define INPUT_ROW 32
#define INPUT_COL 32
#define INPUT_CHANNEL 128

#define OUTPUT_ROW 32
#define OUTPUT_COL 32
#define OUTPUT_CHANNEL 128

#define KERNEL_SIZE 3
#define PADDING 1
#define STRIDE 1

#define N_MACRO 64
#define N_MACRO_PER_GROUP 16
#define N_VCOL 2
#define N_GROUP_VCOL 32 // N_MACRO_PER_GROUP * N_VCOL = 16 * 2 = 32
#define N_GROUP 4
#define N_ROW 64
#define N_COMP 16
#define N_MACRO_REDUCE 1024 // N_ROW * N_COMP = 64 * 16 = 1024;

#define TIME {{ time }} // this value is filled by jinja.
def main(null<int8>){
    // input, weight, mask and index will be prepared in memory image
    global_input = Buffer(<INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __GLOBAL__);
    global_weight = Buffer(<TIME, N_TO, N_GROUP, N_MACRO_PER_GROUP, N_VCOL>, int8, __GLOBAL__);
    global_mask = Buffer(<TIME, N_TO, N_MACRO_PER_GROUP>, int1, __GLOBAL__);
    global_index = Buffer(<TIME, N_TO, N_MACRO_PER_GROUP>, index, __GLOBAL__);
    global_output = Buffer(<OUTPUT_ROW, OUTPUT_COL, OUTPUT_CHANNEL>, int32, __GLOBAL__);

    // Copy input and index into local memory
    local_input = Buffer(<INPUT_ROW, INPUT_COL, INPUT_CHANNEL>, int8, __GLOBAL__);
    Trans(global_input, local_input);
    local_index = Buffer(<TIME, N_TO, N_MACRO_PER_GROUP>, index, __LOCAL__);
    Trans(global_index, local_index);

    // Prepare memory's that will be used

    // Create a buffer to store output
    local_output = Buffer(<OUTPUT_ROW, OUTPUT_COL, OUTPUT_CHANNEL>, int32, __LOCAL__);

    // PIM input reg buffer, it is a double-buffer. Each group use 128 byte, total 4 groups.
    pim_input_reg_buffer = Buffer(<2,4,128>, int8, __PIM_INPUT_REG_BUFFER__);

    // PIM output reg buffer, it's capacity is 4096 bytes, but we use it to store int32 data, so the buffer's shape is 1024
    pim_output_reg_buffer = Buffer(<1024>, int32, __PIM_OUTPUT_REG_BUFFER__);
    
    // Macros
    macros = Buffer(<N_ROW, N_COMP, N_GROUP, N_GROUP_VCOL>, int8, macro);

    SpecialRegSet(INPUT_BIT_WIDTH, 8);
    SpecialRegSet(WEIGHT_BIT_WIDTH, 8);
    SpecialRegSet(OUTPUT_BIT_WIDTH, 32);
    SpecialRegSet(GROUP_SIZE, N_MACRO_PER_GROUP);
    SpecialRegSet(ACTIVATION_GROUP_NUM, N_GROUP);
    SpecialRegSet(ACTIVATION_ELEMENT_COL_NUM, N_GROUP_VCOL);

    
    for time_outer in range(0,TIME/N_MACRO_REDUCE) carry(null){
        index = Load(local_index, [time]);
        for 
    };

    for out_channel_outer_i in range(0, WEIGHT_OUT_CHANNEL/N_GROUP_VCOL) carry (null) {
        out_channel_begin = out_channel_outer_i * N_GROUP_VCOL;

        for weight_reduce_outer_i in range(0, WEIGHT_REDUCE/N_MACRO_REDUCE) carry (null) {
            
            // Step 1: Prepare weight
            use_weight = Slice(weight, 
                        [out_channel_outer_i, weight_reduce_outer_i, 0, 0], // offsets
                        [1,1,N_MACRO_REDUCE, N_GROUP_VCOL],                 // sizes
                        [1,1,1,1]                                           // strides
                        );
            Trans(use_weight, macros); // use_weight can fill macros completely
            
            // Iter over output's height and width
            double_buffer_id = 0
            for oh in range(OUT_HEIGHT) carry(double_buffer_id) {
                for ow in range(OUT_WIDTH) carry(double_buffer_id) {
                    // Prepare to generate one pixel's result (or partial sum)

                    // Double buffer index
                    double_buffer_id = 1 - double_buffer_id;

                    // Step 2: Prepare input
                    //   Case 2.1: load 512 byte  
                    //      TODO: implement this situation
                    plane_size = KERNEL_SIZE * INPUT_CHANNEL;
                    complete_plane_count = 512 / plane_size;
                    remain_size = 512 % plane_size;
                    for plane_idx in range(complete_plane_count){
                        use_local_input = Slice(local_input, [oh + plane_idx, ow, 0], [1, KERNEL_SIZE, INPUT_CHANNEL], [1,1,1]);
                        use_pim_input_reg_buffer = Slice(pim_input_reg_buffer, 
                                 [double_buffer_id, 0], 
                                 [1, plane_size ], 
                                 [1, 1]
                        );
                        Trans(use_local_input, use_pim_input_reg_buffer);
                    };
                    collapsed_local_input = Collapse(local_input, [INPUT_ROW, INPUT_COL * INPUT_CHANNEL]);
                    use_local_input = Slice(collapsed_local_input, [oh + complete_plane_count, ow * INPUT_CHANNEL], [1, KERNEL_SIZE, INPUT_CHANNEL], [1,1,1]);
                    Trans();

                    //   Case 2.2: load whole input sliding window.
                    //      for a 3*3*ic sliding window, it only need three trans.
                    //      TODO: unroll this loop
                    //      TODO: use jinja's if template
                    for kh in range(KERNEL_SIZE){
                        use_local_input = Slice(local_input, [oh + kh, ow, 0], [1, KERNEL_SIZE, INPUT_CHANNEL], [1,1,1]);
                        use_pim_input_reg_buffer = Slice(pim_input_reg_buffer, 
                                [double_buffer_id, 0], 
                                [1, KERNEL_SIZE*INPUT_CHANNEL ], 
                                [1,1]
                        );
                        Trans(use_local_input, use_pim_input_reg_buffer);
                    };

                    // Step 3: do the pim compute
                    // TODO: compute_times = min(N_ROW/2, n_useful_row);
                    compute_times = N_ROW / 2;
                    activate_row_base = double_buffer_id * compute_times;
                    for t in range(compute_times) carry(null){
                        use_input_for_compute = Slice(use_pim_input_reg_buffer, [t * N_COMP], [N_COMP], [1]);
                        
                        activate_row = activate_row_base + t;
                        use_macro_for_compute = Slice(macros, 
                            [activate_row, 0, 0, 0], 
                            [1,  N_COMP, N_GROUP, N_GROUP_VCOL], 
                            [1, 1, 1, 1]
                        );

                        CIMComputeDense(use_input_for_compute, use_macro_for_compute);
                    };
                    use_pim_output_reg = Slice(use_pim_input_reg_buffer, [0], [N_GROUP_VCOL], [1]);
                    CIMClearAndSaveOutput(use_pim_output_reg);

                    // Step 4: save output to local memory, and add to the partial sum
                    Trans(use_pim_output_reg, local_output_temp_for_partial_sum);
                    use_local_output = Slice(local_output, 
                        [oh, ow, out_channel_begin],
                        [1, 1, N_GROUP_VCOL],
                        [1, 1, 1]
                    );
                    VVAdd(use_local_output, local_output_temp_for_partial_sum, use_local_output);
                };
            };
        };
    };
}